---------1---------
// Пример первый. Здесь в комментариях, сделанных в javaDoc формате, обозначены назначения полей для данного конкретного заголовка. Сделано, чтобы избежать путаницы и облегчить работу с типом данных.

public class Header {
  /** Система отправителя или источник сообщения. */
  private final String source;
  /** Категория сообщения, которая определяет его цель и возможную логику обработки. */
  private final MessageType messageType;
  /** Название типа данных и структуры тела сообщения. */
  private final String bodyType;
  /** Формат, в котором закодировано тело сообщения с данными. */
  private final String bodyEncoding;
  /** Тип обновления для сообщей типа {@link DataMessage}. */
  private final UpdateType updateType;
  /** Обновленные поля. Заполняются в случае, если {@link #updateType} = {@link UpdateType#PARTIAL}. */
  private final Set<String> updatedFields;
  /** Поколение данных. */
  private final long generation;
}


---------2---------
// Пример второй. Еще одно JavaDoc описание класса. Сделано с теми же целями, что и в первом примере.

/**
 * Реализация сериализации/десереализации JSON тела сообщения согласно спецификации протокола. В
 * частности:
 * <ul>
 * <li>Кодировка - UTF-8</li>
 * <li>Использование "Pretty printing" возможно (перевод строки - LF), но опционально</li>
 * <li>JSON содержит только аттрибуты, присутствующие в передаваемой сущности</li>
 * <li>JSON содержит все не null свойства передаваемой сущности</li>
 * <li>null значения не записываются в json</li>
 * <li>Порядок следования аттрибутов не определен</li>
 * </ul>
 * <p>
 * Поддерживает запись исключительно полей следующих типов: {@link BHJacksonModule#allowedTypes}
 */
public class JsonMapper implements Encoder, Decoder {...}


---------3---------
// Пример третий, аналогичен первому и второму.

/**
 * Категория сообщения, которая определяет его цель и возможную логику обработки.
 */
public enum MessageType {
  /** Системное уведомление или управлющее собитие. */
  CONTROL,
  /** Пркладное сообщение с информационным объектом. */
  DATA,
  /** Описание структур, схем и версионности данных информационных объектов. */
  METADATA,
  /** Пакеты системного назначения для мониторинга и отслеживания состояния. */
  MONITORING
}


---------4---------
// Пример четвертый. Из-за нюансов источников данных иногда приходится делать дополнительные функции\опции

/**
 * Тип обновления данных.
 * <p>
 * Актуален только для сообщения, типа соощений {@link MessageType#DATA}.
 * Некоторые источники данных могут обновлять не весь объект, а лишь часть его полей.
 * В таком случае, потребитель должен иметь возможность понять, с какми обновлением он имеет дело:
 * пришел объет целиком, или только часть его полей. Этот enum для этого.
 */
public enum UpdateType {
  /** Объект целиком. */
  FULL,
  /** Некоторые поля объекта. */
  PARTIAL
}


---------5---------
// Пример пятый. Метод, работа которого имеет нюансы, о которых хорошо помнить и которые тяжело отобразить в названии.

  /**
   * Проставить текущее время в специальное поле pojo, если оно есть
   *
   * @param pojo в какой объект проставить значение
   * @return имя поля, в которое было проставлено текущее время или null, если поле отсутствует в классе объекта
   */
  public String setCurrentTime(V pojo) {...}


---------6---------
// Пример шестой. Здесь от источника приходит значение в определенном формате и сделана пометка в виде комментария, которая помогает коллегам сразу начать работу, если потребуется

  // от источника приходит значение вида "2020-04-03T12:35:11Z"
  public static LocalDateTime getLocalDTFromZonedString(JsonNode parent, String field) {


---------7---------
// Пример седьмой. Сделанные изменения бессмысленны с точки зрения логики работы приложения и по факту являются костылем. Необходимость в нем возникла из-за изменений в источнике данных, за который отвчает совершенно другое подразделение компании. В итоге, было сделано изменение и пометка к нему, объясняющее зачем оно нужно и с какой задачей было связано.

  // statelessSubscribe подписки, где в качестве репозитория передается пустышка.
  // Сделано в рамках задачи ESB-3007, где для сущности model.cat.Auctionorders вместо FullUpdate стали
  // приходить PartialUpdate и в логи записывался error: "Received partial update for stateless subscription...".
  protected <K, V> void statelessSubscribeDummy(PojoInfo<K, V> pojoInfo, NewValueEntityUpdateProcessor<K, V, T, R> onUpsert, Consumer<ResetStateReason> resetState, ClearPolicy clearPolicy) {...}